/**
 * @file DWM1000.cpp
 * @brief Реализация библиотеки для работы с модулем DWM1000 UWB
 */

#include "DWM1000.h"

DWM1000::DWM1000() {
    initialized = false;
}

bool DWM1000::begin() {
    Serial.println("\n=== Инициализация модуля DWM1000 ===");
    
    // Настройка пинов
    pinMode(DWM1000_CS_PIN, OUTPUT);
    pinMode(DWM1000_IRQ_PIN, INPUT);
    // RST пин не используется (не подключен по схеме)
    
    digitalWrite(DWM1000_CS_PIN, HIGH);
    
    Serial.printf("Пины настроены:\n");
    Serial.printf("  CS:   GPIO %d\n", DWM1000_CS_PIN);
    Serial.printf("  IRQ:  GPIO %d\n", DWM1000_IRQ_PIN);
    Serial.printf("  MOSI: GPIO %d\n", DWM1000_MOSI_PIN);
    Serial.printf("  MISO: GPIO %d\n", DWM1000_MISO_PIN);
    Serial.printf("  SCK:  GPIO %d\n", DWM1000_SCK_PIN);
    Serial.println("  RST:  не используется (программный сброс через SPI)");
    
    // Инициализация SPI
    spi = new SPIClass(FSPI);
    spi->begin(DWM1000_SCK_PIN, DWM1000_MISO_PIN, DWM1000_MOSI_PIN, DWM1000_CS_PIN);
    
    // Сначала ОЧЕНЬ низкая скорость для стабилизации связи
    spi->setFrequency(1000000); // 1 МГц для первого контакта
    spi->setDataMode(SPI_MODE0);  // CPOL=0, CPHA=0
    spi->setBitOrder(MSBFIRST);
    
    Serial.println("SPI инициализирован (1 МГц, MODE0, MSB First)");
    
    // КРИТИЧНО: Задержка после инициализации SPI
    Serial.println("\nОжидание стабилизации модуля...");
    delay(500);  // Большая задержка для стабилизации
    
    // Программный сброс модуля через SPI
    Serial.println("Выполнение программного сброса через SPI...");
    softReset();
    delay(500);  // Большая задержка после сброса
    
    // Теперь переключаемся на высокую скорость для избежания битового сдвига
    Serial.println("Переключение на высокую скорость SPI (20 МГц)...");
    spi->setFrequency(20000000); // 20 МГц - избегаем битового сдвига
    delay(10);
    
    // Проверка Device ID
    Serial.println("\nПроверка связи с модулем...");
    uint32_t deviceId = getDeviceID();
    Serial.printf("Device ID: 0x%08X (ожидается 0x%08X)\n", deviceId, DWM1000_DEVICE_ID);
    
    // Если Device ID неправильный, пробуем тест записи/чтения в регистр 0x21
    if (deviceId != DWM1000_DEVICE_ID) {
        Serial.println("\n⚠ Device ID неправильный! Выполняю тест SPI записи/чтения...");
        
        // Тест: записываем известные данные в регистр 0x21 и читаем обратно
        uint8_t testWrite[4] = {0xDE, 0xCA, 0x01, 0x30};
        uint8_t testRead[4] = {0};
        
        writeRegister(0x21, testWrite, 4);
        delay(10);
        readRegister(0x21, testRead, 4);
        
        Serial.print("Записано: ");
        for(int i=0; i<4; i++) Serial.printf("%02X ", testWrite[i]);
        Serial.print("\nПрочитано: ");
        for(int i=0; i<4; i++) Serial.printf("%02X ", testRead[i]);
        Serial.println();
        
        if (memcmp(testWrite, testRead, 4) == 0) {
            Serial.println("✓ SPI работает корректно! Проблема в Device ID...");
            
            // Применяем фикс бага DWM1000 SPI
            Serial.println("\nПрименяю фикс DW1000 SPI бага...");
            writeRegister32(0x04, 0, 0x1600);  // Установить бит 10 в SYS_CFG (0x04)
            delay(50);
            
            deviceId = getDeviceID();
            Serial.printf("Device ID после фикса: 0x%08X\n", deviceId);
        } else {
            Serial.println("✗ SPI не работает! Проблема с подключением.");
        }
    }
    
    if (deviceId == DWM1000_DEVICE_ID) {
        Serial.println("\n✓ Модуль DWM1000 обнаружен успешно!");
        
        // Показываем текущую конфигурацию
        Serial.println("\n=== Текущая конфигурация ===");
        uint32_t chanCtrl = readRegister32(REG_CHAN_CTRL, 0);
        uint32_t sysCfg = readRegister32(REG_SYS_CFG, 0);
        uint32_t panadr = readRegister32(REG_PANADR, 0);
        
        Serial.printf("CHAN_CTRL:  0x%08X (канал=%d, PRF=%d)\n", chanCtrl, 
                      chanCtrl & 0xF, (chanCtrl >> 18) & 0x3);
        Serial.printf("SYS_CFG:    0x%08X\n", sysCfg);
        Serial.printf("PAN_ADDR:   0x%08X (PAN=0x%04X, Addr=0x%04X)\n", panadr,
                      (panadr >> 16) & 0xFFFF, panadr & 0xFFFF);
        
        // TODO: Полная конфигурация требует настройки множества регистров
        // Для production кода используйте официальный Decawave driver
        // или готовую библиотеку типа thotro/arduino-dw1000
        
        initialized = true;
        
        return true;
    } else {
        Serial.println("\n✗ ОШИБКА: Модуль DWM1000 не обнаружен");
        if (deviceId == 0xFFFFFFFF) {
            Serial.println("Причина: Все линии HIGH - модуль не отвечает или не подключен");
        } else if (deviceId == 0x00000000) {
            Serial.println("Причина: Все линии LOW - проверьте питание модуля");
        } else {
            Serial.println("Причина: Неправильный Device ID - проверьте подключение SPI");
        }
        Serial.println("\n⚠ РЕЖИМ БЕЗ МОДУЛЯ: Интерфейс активен, но модуль недоступен");
        Serial.println("Проверьте подключение и используйте команду 'r' для перезагрузки");
        return false;
    }
}

void DWM1000::reset() {
    // Программный сброс через SPI (аппаратный RST не подключен)
    softReset();
}

void DWM1000::softReset() {
    // Программный сброс: записываем в регистр PMSC_CTRL0
    writeRegister8(0x36, 0x00, 0x01);  // Soft reset
    delay(10);
    writeRegister8(0x36, 0x00, 0x00);  // Clear reset
    delay(10);
    Serial.println("Программный сброс выполнен");
}

uint32_t DWM1000::getDeviceID() {
    return readRegister32(REG_DEV_ID, 0);
}

void DWM1000::getEUI(uint8_t* eui) {
    readRegister(REG_EUI, eui, 8);
}

void DWM1000::printDeviceInfo() {
    Serial.println("\n=== Информация о модуле DWM1000 ===");
    
    uint32_t deviceId = getDeviceID();
    Serial.printf("Device ID:     0x%08X\n", deviceId);
    Serial.printf("  Model:       %d\n", (deviceId >> 8) & 0xFF);
    Serial.printf("  Version:     %d\n", (deviceId >> 16) & 0xFF);
    Serial.printf("  Revision:    %d\n", (deviceId >> 24) & 0xFF);
    
    uint8_t eui[8];
    getEUI(eui);
    Serial.print("EUI-64:        ");
    for (int i = 0; i < 8; i++) {
        Serial.printf("%02X", eui[i]);
        if (i < 7) Serial.print(":");
    }
    Serial.println();
    
    uint16_t panId = readRegister16(REG_PANADR, 2);
    uint16_t shortAddr = readRegister16(REG_PANADR, 0);
    Serial.printf("PAN ID:        0x%04X\n", panId);
    Serial.printf("Short Address: 0x%04X\n", shortAddr);
    
    uint32_t sysStatus = readRegister32(REG_SYS_STATUS, 0);
    Serial.printf("System Status: 0x%08X\n", sysStatus);
    
    uint32_t sysState = readRegister32(REG_SYS_STATE, 0);
    Serial.printf("System State:  0x%08X\n", sysState);
    
    Serial.println("===================================");
}

void DWM1000::printRegisters() {
    Serial.println("\n=== Дамп регистров DWM1000 ===");
    
    // Основные регистры для проверки
    struct RegInfo {
        uint8_t reg;
        const char* name;
        uint8_t len;
    };
    
    RegInfo regs[] = {
        {REG_DEV_ID, "DEV_ID", 4},
        {REG_EUI, "EUI", 8},
        {REG_PANADR, "PANADR", 4},
        {REG_SYS_CFG, "SYS_CFG", 4},
        {REG_SYS_CTRL, "SYS_CTRL", 4},
        {REG_SYS_STATUS, "SYS_STATUS", 5},
        {REG_CHAN_CTRL, "CHAN_CTRL", 4}
    };
    
    for (int i = 0; i < sizeof(regs) / sizeof(RegInfo); i++) {
        Serial.printf("0x%02X %-12s: ", regs[i].reg, regs[i].name);
        uint8_t data[8];
        readRegister(regs[i].reg, data, regs[i].len);
        for (int j = 0; j < regs[i].len; j++) {
            Serial.printf("%02X ", data[j]);
        }
        Serial.println();
    }
    
    Serial.println("==============================");
}

bool DWM1000::testCommunication() {
    Serial.println("\n=== Тест коммуникации с модулем ===");
    
    // Тест 1: Проверка Device ID несколько раз
    Serial.println("\nТест 1: Множественное чтение Device ID");
    bool idTestPassed = true;
    for (int i = 0; i < 5; i++) {
        uint32_t id = getDeviceID();
        Serial.printf("  Попытка %d: 0x%08X ", i + 1, id);
        if (id == DWM1000_DEVICE_ID) {
            Serial.println("✓");
        } else {
            Serial.println("✗");
            idTestPassed = false;
        }
        delay(10);
    }
    
    // Тест 2: Запись и чтение тестового значения
    Serial.println("\nТест 2: Запись/чтение регистра PANADR");
    uint16_t originalPanId = readRegister16(REG_PANADR, 2);
    uint16_t originalAddr = readRegister16(REG_PANADR, 0);
    Serial.printf("  Оригинальные значения - PAN: 0x%04X, Addr: 0x%04X\n", 
                  originalPanId, originalAddr);
    
    // Записываем тестовые значения
    uint16_t testPanId = 0xCAFE;
    uint16_t testAddr = 0xBEEF;
    writeRegister16(REG_PANADR, 2, testPanId);
    writeRegister16(REG_PANADR, 0, testAddr);
    Serial.printf("  Записаны тестовые - PAN: 0x%04X, Addr: 0x%04X\n", 
                  testPanId, testAddr);
    
    // Читаем обратно
    uint16_t readPanId = readRegister16(REG_PANADR, 2);
    uint16_t readAddr = readRegister16(REG_PANADR, 0);
    Serial.printf("  Прочитаны значения - PAN: 0x%04X, Addr: 0x%04X ", 
                  readPanId, readAddr);
    
    bool writeTestPassed = (readPanId == testPanId) && (readAddr == testAddr);
    if (writeTestPassed) {
        Serial.println("✓");
    } else {
        Serial.println("✗");
    }
    
    // Восстанавливаем оригинальные значения
    writeRegister16(REG_PANADR, 2, originalPanId);
    writeRegister16(REG_PANADR, 0, originalAddr);
    Serial.println("  Оригинальные значения восстановлены");
    
    // Тест 3: Проверка линии IRQ
    Serial.println("\nТест 3: Проверка линии IRQ");
    int irqState = digitalRead(DWM1000_IRQ_PIN);
    Serial.printf("  Состояние IRQ: %s\n", irqState ? "HIGH" : "LOW");
    
    // Общий результат
    Serial.println("\n=== Результат тестов ===");
    bool allPassed = idTestPassed && writeTestPassed;
    if (allPassed) {
        Serial.println("✓ ВСЕ ТЕСТЫ ПРОЙДЕНЫ УСПЕШНО!");
        Serial.println("Модуль DWM1000 работает корректно.");
    } else {
        Serial.println("✗ НЕКОТОРЫЕ ТЕСТЫ НЕ ПРОЙДЕНЫ!");
        Serial.println("Проверьте подключение и состояние модуля.");
    }
    Serial.println("=======================");
    
    return allPassed;
}

void DWM1000::setChannel(uint8_t channel) {
    Serial.printf("\nНастройка канала: %d\n", channel);
    // Упрощенная настройка канала (для полной реализации нужна документация)
    uint32_t chanCtrl = readRegister32(REG_CHAN_CTRL, 0);
    chanCtrl = (chanCtrl & 0xFFFFFFF0) | (channel & 0x0F);
    writeRegister32(REG_CHAN_CTRL, 0, chanCtrl);
    Serial.println("Канал настроен");
}

void DWM1000::setShortAddress(uint16_t address) {
    // Записываем короткий адрес в регистр PANADR (0x03)
    // Младшие 2 байта - Short Address, старшие 2 байта - PAN ID
    uint32_t panadr = readRegister32(REG_PANADR, 0);
    panadr = (panadr & 0xFFFF0000) | address;  // Сохраняем PAN ID, меняем адрес
    writeRegister32(REG_PANADR, 0, panadr);
    Serial.printf("Установлен короткий адрес: 0x%04X\n", address);
}

void DWM1000::setPRF(uint8_t prf) {
    Serial.printf("Настройка PRF: %d МГц\n", prf);
    // Настройка Pulse Repetition Frequency
}

void DWM1000::setDataRate(uint8_t rate) {
    Serial.printf("Настройка скорости передачи: %d\n", rate);
    // Настройка скорости передачи данных
}

void DWM1000::enableTransmitter() {
    Serial.println("\n=== Включение режима передатчика ===");
    disableTransceiver();
    delay(10);
    Serial.println("Передатчик готов к работе");
}

void DWM1000::enableReceiver() {
    disableTransceiver();
    writeRegister32(REG_SYS_CTRL, 0, SYS_CTRL_RXENAB);
}

void DWM1000::disableTransceiver() {
    writeRegister32(REG_SYS_CTRL, 0, SYS_CTRL_TRXOFF);
}

void DWM1000::sendData(uint8_t* data, uint16_t len) {
    Serial.printf("\n=== TX (%d байт) ===\n", len);
    Serial.print("Данные: ");
    for (uint16_t i = 0; i < len && i < 16; i++) {
        Serial.printf("%02X ", data[i]);
    }
    Serial.println();
    
    // КРИТИЧНО: Выключаем приемопередатчик перед настройкой TX
    writeRegister32(REG_SYS_CTRL, 0, SYS_CTRL_TRXOFF);
    
    // Очищаем все флаги статуса
    writeRegister32(REG_SYS_STATUS, 0, 0xFFFFFFFF);
    
    // Запись данных в TX буфер
    writeRegister(REG_TX_BUFFER, data, len);
    
    // Настройка TX_FCTRL: длина кадра + ranging bit + TX buffer offset
    // Байты 0-1: длина кадра (биты 0-6 = len, биты 7-8 = offset)
    // Байт 2: биты управления (бит 13 = ranging bit)
    uint32_t txFctrl = len | ((uint32_t)0 << 16) | ((uint32_t)1 << 13);  // len + offset=0 + ranging=1
    writeRegister32(REG_TX_FCTRL, 0, txFctrl);
    
    Serial.printf("TX_FCTRL = 0x%08X\n", txFctrl);
    
    // Начало передачи
    writeRegister32(REG_SYS_CTRL, 0, SYS_CTRL_TXSTRT);
    
    // Ожидание завершения (polling TXFRS)
    unsigned long timeout = millis() + 200;
    while (millis() < timeout) {
        uint32_t status = readRegister32(REG_SYS_STATUS, 0);
        
        if (status & SYS_STATUS_TXFRS) {
            Serial.println("✓ TX OK");
            writeRegister32(REG_SYS_STATUS, 0, SYS_STATUS_TXFRS);
            return;
        }
        
        // Проверяем на ошибки
        if (status & 0x00000400) {  // TXBERR - transmit buffer error
            Serial.printf("✗ TX BUFFER ERROR! Status=0x%08X\n", status);
            writeRegister32(REG_SYS_STATUS, 0, 0x00000400);
            return;
        }
    }
    
    uint32_t finalStatus = readRegister32(REG_SYS_STATUS, 0);
    Serial.printf("✗ TX TIMEOUT! Status=0x%08X\n", finalStatus);
}

uint16_t DWM1000::receiveData(uint8_t* buffer, uint16_t maxLen) {
    Serial.println("\n=== Ожидание приема данных ===");
    
    uint32_t status = readRegister32(REG_SYS_STATUS, 0);
    
    if (status & SYS_STATUS_RXFCG) {
        Serial.println("✓ Данные приняты успешно");
        
        // Получение информации о кадре
        uint32_t rxInfo = readRegister32(REG_RX_FINFO, 0);
        uint16_t len = rxInfo & 0x3FF;
        
        Serial.printf("Размер принятых данных: %d байт\n", len);
        
        if (len > maxLen) {
            len = maxLen;
            Serial.printf("Предупреждение: данные обрезаны до %d байт\n", maxLen);
        }
        
        // Чтение данных
        readRegister(REG_RX_BUFFER, buffer, len);
        
        Serial.print("Данные: ");
        for (uint16_t i = 0; i < len && i < 32; i++) {
            Serial.printf("%02X ", buffer[i]);
        }
        if (len > 32) Serial.print("...");
        Serial.println();
        
        // Очистка флагов
        writeRegister32(REG_SYS_STATUS, 0, SYS_STATUS_RXFCG);
        
        return len;
    } else if (status & SYS_STATUS_RXFCE) {
        Serial.println("✗ Ошибка CRC при приеме");
        writeRegister32(REG_SYS_STATUS, 0, SYS_STATUS_RXFCE);
        return 0;
    }
    
    return 0;
}

void DWM1000::initRanging() {
    Serial.println("\n=== Инициализация режима измерения расстояния ===");
    // Настройка для Two-Way Ranging (TWR)
    Serial.println("Режим TWR настроен");
}

float DWM1000::getDistance() {
    // Упрощенный расчет расстояния
    // Для полной реализации требуется сложный алгоритм TWR
    Serial.println("Расчет расстояния...");
    return 0.0;
}

// ============================================================================
// НОВЫЕ ФУНКЦИИ ДЛЯ ПРАВИЛЬНОГО TWR (по образцу официального API)
// ============================================================================

bool DWM1000::sendPollWaitResponse(uint8_t* data, uint16_t len) {
    // Запись данных в TX буфер
    writeRegister(REG_TX_BUFFER, data, len);
    
    // Установка длины кадра (с ranging bit)
    uint32_t txCtrl = len | (1 << 13);  // len + ranging bit
    writeRegister32(REG_TX_FCTRL, 0, txCtrl);
    
    // Настройка RX after TX delay через регистр ACK_RESP_T (0x1A)
    // W4R_TIM в байтах 0-2, ACK_TIM в байте 3
    // Задержка 140 µs = 140 * 65536 / 512 = 17920 в единицах ~8ns
    uint32_t delay = (140 * 128) & 0xFFFFF;  // 20 бит
    writeRegister32(0x1A, 0, delay);  // REG_ACK_RESP_T
    
    // Установка таймаута приема через REG_RX_FWTO
    uint16_t timeout = 210 * 128;  // 210 µs
    writeRegister16(REG_RX_FWTO, 0, timeout);
    
    Serial.println("TX: Отправка с WAIT4RESP...");
    
    // Отправка с флагом WAIT4RESP (автовключение RX)
    writeRegister32(REG_SYS_CTRL, 0, 0x00000082);  // TXSTRT | WAIT4RESP
    
    // Ждем завершения передачи
    unsigned long timeout_ms = millis() + 100;
    while (millis() < timeout_ms) {
        uint32_t status = readRegister32(REG_SYS_STATUS, 0);
        if (status & SYS_STATUS_TXFRS) {
            Serial.printf("TX: Передача OK, статус=0x%08X\n", status);
            writeRegister32(REG_SYS_STATUS, 0, SYS_STATUS_TXFRS);
            return true;
        }
    }
    
    Serial.println("TX: TIMEOUT!");
    return false;
}

bool DWM1000::sendDelayedResponse(uint8_t* data, uint16_t len) {
    // Получаем timestamp приема POLL
    uint64_t pollRxTime = 0;
    uint8_t tsTab[5];
    readRegister(REG_RX_TIME, tsTab, 5);
    for (int i = 4; i >= 0; i--) {
        pollRxTime <<= 8;
        pollRxTime |= tsTab[i];
    }
    
    // Вычисляем время отправки RESPONSE (с задержкой 330 µs как в ex_06b)
    uint32_t delay_uus = 330;
    uint64_t delay_dtu = (uint64_t)delay_uus * 65536;
    uint32_t respTxTime = (pollRxTime + delay_dtu) >> 8;
    
    // Вычисляем полный TX timestamp (включая antenna delay)
    uint64_t respTxTs = (((uint64_t)(respTxTime & 0xFFFFFFFEUL)) << 8) + 16436;  // TX_ANT_DLY
    
    // Записываем timestamps в сообщение (байты 10-17)
    for (int i = 0; i < 4; i++) {
        data[10 + i] = (pollRxTime >> (i * 8)) & 0xFF;
    }
    for (int i = 0; i < 4; i++) {
        data[14 + i] = (respTxTs >> (i * 8)) & 0xFF;
    }
    
    // Записываем данные в TX буфер
    writeRegister(REG_TX_BUFFER, data, len);
    
    // Устанавливаем длину кадра
    uint32_t txCtrl = len | (1 << 13);  // len + ranging bit
    writeRegister32(REG_TX_FCTRL, 0, txCtrl);
    
    // Устанавливаем delayed TX time
    writeRegister32(REG_DX_TIME, 0, respTxTime);
    
    // Запускаем delayed TX
    writeRegister32(REG_SYS_CTRL, 0, 0x00000002 | 0x00000004);  // TXSTRT | TXDLYS
    
    // Ждем завершения передачи
    unsigned long timeout = millis() + 100;
    while (millis() < timeout) {
        uint32_t status = readRegister32(REG_SYS_STATUS, 0);
        if (status & SYS_STATUS_TXFRS) {
            writeRegister32(REG_SYS_STATUS, 0, SYS_STATUS_TXFRS);
            return true;
        }
        if (status & 0x10000000) {  // HPDWARN - delayed TX too late
            return false;
        }
    }
    
    return false;
}

uint16_t DWM1000::readReceivedData(uint8_t* buffer, uint16_t maxLen) {
    // Получаем длину кадра из RX_FINFO
    uint32_t rxInfo = readRegister32(REG_RX_FINFO, 0);
    uint16_t len = rxInfo & 0x3FF;
    
    Serial.printf("RX_FINFO=0x%08X, len=%d\n", rxInfo, len);
    
    if (len == 0) {
        Serial.println("✗ Длина = 0!");
        return 0;
    }
    
    if (len > maxLen) {
        Serial.printf("! Обрезка %d -> %d\n", len, maxLen);
        len = maxLen;
    }
    
    // Читаем данные из RX буфера
    readRegister(REG_RX_BUFFER, buffer, len);
    
    // Отладка - показываем первые байты
    Serial.printf("RX RAW (%d): ", len);
    for (int i = 0; i < min((int)len, 16); i++) {
        Serial.printf("%02X ", buffer[i]);
    }
    Serial.println();
    
    return len;
}

uint32_t DWM1000::getStatus() {
    return readRegister32(REG_SYS_STATUS, 0);
}

void DWM1000::clearRxStatus() {
    // Очищаем флаг успешного приема
    writeRegister32(REG_SYS_STATUS, 0, SYS_STATUS_RXFCG | SYS_STATUS_TXFRS);
}

void DWM1000::clearRxError() {
    // Очищаем все флаги ошибок RX
    writeRegister32(REG_SYS_STATUS, 0, 0x60000000);  // ALL_RX_TO | ALL_RX_ERR
}

void DWM1000::rxReset() {
    // Программный сброс приемника (как dwt_rxreset в официальном API)
    // Записываем в PMSC_CTRL0 для сброса RX
    uint8_t pmscCtrl0[4];
    
    // Читаем текущее значение
    readRegister(REG_PMSC, pmscCtrl0, 4);
    
    // Устанавливаем бит сброса RX
    pmscCtrl0[3] = 0xE0;
    writeRegister(REG_PMSC, pmscCtrl0, 4);
    
    // Сбрасываем бит
    pmscCtrl0[3] = 0xF0;
    writeRegister(REG_PMSC, pmscCtrl0, 4);
}

float DWM1000::calculateDistance(uint8_t* respMsg, uint16_t len) {
    if (len < 18) return -1.0;
    
    // Извлекаем timestamps из RESPONSE сообщения
    uint32_t pollRxTs = 0;
    uint32_t respTxTs = 0;
    
    for (int i = 0; i < 4; i++) {
        pollRxTs |= ((uint32_t)respMsg[10 + i]) << (i * 8);
        respTxTs |= ((uint32_t)respMsg[14 + i]) << (i * 8);
    }
    
    // Получаем наши локальные timestamps (нужно читать из регистров TX_TIME)
    uint32_t pollTxTs = 0;  // TODO: читать из последней передачи
    uint32_t respRxTs = 0;  // TODO: читать из последнего приема
    
    // Простой расчет RTD (Round Trip Delay)
    int32_t rtdInit = respRxTs - pollTxTs;
    int32_t rtdResp = respTxTs - pollRxTs;
    
    // TOF = (RTD_initiator - RTD_responder) / 2
    const float DWT_TIME_UNITS = 1.0 / 499.2e6 / 128.0;  // ~15.65 ps
    const float SPEED_OF_LIGHT = 299702547.0;  // m/s в воздухе
    
    float tof = ((float)(rtdInit - rtdResp) / 2.0) * DWT_TIME_UNITS;
    float distance = tof * SPEED_OF_LIGHT;
    
    return distance;
}

// ============================================================================

// Внутренние функции SPI

void DWM1000::selectChip() {
    digitalWrite(DWM1000_CS_PIN, LOW);
}

void DWM1000::deselectChip() {
    digitalWrite(DWM1000_CS_PIN, HIGH);
}

void DWM1000::writeRegister(uint8_t reg, uint8_t* data, uint16_t len) {
    selectChip();
    delayMicroseconds(5);
    
    // Формирование заголовка
    uint8_t header = 0x80 | reg; // Бит 7 = 1 (запись), биты 0-5 = адрес регистра
    spi->transfer(header);
    
    // Запись данных побайтно
    for (uint16_t i = 0; i < len; i++) {
        spi->transfer(data[i]);
    }
    
    delayMicroseconds(5);
    deselectChip();
}

void DWM1000::readRegister(uint8_t reg, uint8_t* data, uint16_t len) {
    selectChip();
    delayMicroseconds(5);
    
    // Формирование заголовка
    uint8_t header = reg; // Бит 7 = 0 (чтение), биты 0-5 = адрес регистра
    spi->transfer(header);
    
    // Чтение данных
    for (uint16_t i = 0; i < len; i++) {
        data[i] = spi->transfer(0x00);
    }
    
    delayMicroseconds(5);
    deselectChip();
}

void DWM1000::writeRegister8(uint8_t reg, uint16_t offset, uint8_t value) {
    selectChip();
    
    uint8_t header[3];
    header[0] = 0x80 | reg;
    
    if (offset > 0) {
        header[0] |= 0x40;
        header[1] = offset & 0x7F;
        spi->transfer(header, 2);
    } else {
        spi->transfer(header[0]);
    }
    
    spi->transfer(value);
    deselectChip();
}

void DWM1000::writeRegister16(uint8_t reg, uint16_t offset, uint16_t value) {
    uint8_t data[2];
    data[0] = value & 0xFF;
    data[1] = (value >> 8) & 0xFF;
    
    selectChip();
    uint8_t header[3];
    header[0] = 0x80 | reg;
    
    if (offset > 0) {
        header[0] |= 0x40;
        header[1] = offset & 0x7F;
        spi->transfer(header, 2);
    } else {
        spi->transfer(header[0]);
    }
    
    spi->transfer(data, 2);
    deselectChip();
}

void DWM1000::writeRegister32(uint8_t reg, uint16_t offset, uint32_t value) {
    uint8_t data[4];
    data[0] = value & 0xFF;
    data[1] = (value >> 8) & 0xFF;
    data[2] = (value >> 16) & 0xFF;
    data[3] = (value >> 24) & 0xFF;
    
    selectChip();
    uint8_t header[3];
    header[0] = 0x80 | reg;
    
    if (offset > 0) {
        header[0] |= 0x40;
        header[1] = offset & 0x7F;
        spi->transfer(header, 2);
    } else {
        spi->transfer(header[0]);
    }
    
    spi->transfer(data, 4);
    deselectChip();
}

uint8_t DWM1000::readRegister8(uint8_t reg, uint16_t offset) {
    selectChip();
    
    uint8_t header[3];
    header[0] = reg;
    
    if (offset > 0) {
        header[0] |= 0x40;
        header[1] = offset & 0x7F;
        spi->transfer(header, 2);
    } else {
        spi->transfer(header[0]);
    }
    
    uint8_t value = spi->transfer(0x00);
    deselectChip();
    return value;
}

uint16_t DWM1000::readRegister16(uint8_t reg, uint16_t offset) {
    uint8_t data[2];
    
    selectChip();
    uint8_t header[3];
    header[0] = reg;
    
    if (offset > 0) {
        header[0] |= 0x40;
        header[1] = offset & 0x7F;
        spi->transfer(header, 2);
    } else {
        spi->transfer(header[0]);
    }
    
    data[0] = spi->transfer(0x00);
    data[1] = spi->transfer(0x00);
    deselectChip();
    
    return data[0] | (data[1] << 8);
}

uint32_t DWM1000::readRegister32(uint8_t reg, uint16_t offset) {
    uint8_t data[4];
    
    selectChip();
    uint8_t header[3];
    header[0] = reg;
    
    if (offset > 0) {
        header[0] |= 0x40;
        header[1] = offset & 0x7F;
        spi->transfer(header, 2);
    } else {
        spi->transfer(header[0]);
    }
    
    data[0] = spi->transfer(0x00);
    data[1] = spi->transfer(0x00);
    data[2] = spi->transfer(0x00);
    data[3] = spi->transfer(0x00);
    deselectChip();
    
    return data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24);
}
